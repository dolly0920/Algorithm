최대 K가지의 서로 다른 색을 표현할 수 있는 전구들이 있다. 이 전구 N개를 다음의 그림과 같이 한 줄로 배치하여 서로 연결한다. (동그라미 안의 숫자는 전구의 색을 의미한다)



각 전구는 스위치가 있어서 전구의 색을 임의의 색으로 바꿀 수 있다. 하나의 전구 색을 바꾸는 경우에는, 색이 바뀌는 전구에 인접한 전구가 같은 색이면, 이 전구의 색도 같이 바뀌게 되며 인접한 전구가 다른 색이 나올 때까지 계속 바뀌게 된다. 예를 들어, 위의 그림에서 4번 전구의 색을 2번 색으로 바꾸면, 5번 전구가 4번 전구와 같은 색이었으므로 2번 색으로 바뀌고, 6번 전구도 5번 전구와 같은 색이었으므로 2번 색으로 바뀌게 된다. 즉, 4번 전구의 색을 2번 색으로 바꾸면, 연결된 같은 색의 모든 전구인 4, 5, 6번의 전구가 2번 색으로 바뀌게 되어 아래의 그림과 같이 된다.



전구의 수 N과 N개의 전등에 대한 초기 색이 주어질 때, 모든 전구의 색이 하나로 같아질 때까지 최소 몇 번 전구의 색을 바꾸어야 하는지를 구하는 프로그램을 작성하시오. 단, 전구의 각 색은 1부터 K까지의 정수로 나타낸다.
----------------------------------------------------------------------------------------------------------------
//My sol
#include <stdio.h>

#define INF 1000000000

int N, K;
int d[200 + 10][200 + 10];
int a[200 + 10];

int min(int a, int b)
{
	return (a > b) ? b : a;
}

int dp(int s, int e)	// s-e의 최소 횟수
{
	int i,tmp;

	if (s == e)	return 0;	// 같은 경우 0
	if (d[s][e] != -1)	return d[s][e];

	d[s][e] = INF;

	for (i = s; i <= e; i++)	// s,e사이에 i로 모든 임의의 수 고려함
	{
		if (a[s] != a[i + 1])	tmp = 1;
		else	tmp = 0;

		d[s][e] = min(d[s][e], dp(s, i) + dp(i + 1, e) + tmp);
	}

	return d[s][e];
}

int main(void)
{
	int i;

	scanf("%d %d", &N, &K);

	for (i = 0; i < N; i++)
	{
		scanf("%d", &a[i]);
	}

	memset(d,-1,sizeof(d));

	printf("%d", dp(0, N - 1));

	return 0; 
}