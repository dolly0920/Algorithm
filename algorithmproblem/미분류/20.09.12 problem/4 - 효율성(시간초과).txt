import heapq as hq
import sys

def solution(n, s, a, b, fares): ## 지점갯수, 출발지점, a의 도착지점, b의 도착지점, 요금 2차원 배열
    answer = 0
    path = [{} for _ in range (n)]

    for x,y,z in fares :
        path[x-1][y-1] = z
        path[y-1][x-1] = z

    pq = []
    hq.heappush(pq,(0,s-1,s-1)) ## (총 가중치, a의 노드, b의 노드)
    dist = [[sys.maxsize]*n for _ in range(n)] ## dist[i][j] : a가 i, b가 j에 있을 때의 총 가중치 최소값
    dist[s-1][s-1] = 0 ## 출발 지점은 가중치 0

    while pq :
        cur_cost,cur_a,cur_b = hq.heappop(pq) ## 현재 가중치, 현재 a노드, 현재 b노드
        if cur_a != a-1 and cur_b != b-1 : ## 둘 다 도착하지 않은 경우
            possible_a = [x for x in path[cur_a]]
            possible_b = [x for x in path[cur_b]]
            for x in possible_a :
                for y in possible_b :
                    cost = path[cur_a][x]+path[cur_b][y]
                    if x == y : ## 같은 지점으로 간다면
                        if dist[x][y] > cur_cost + (cost//2) :
                            dist[x][y] = cur_cost+(cost//2)
                            hq.heappush(pq,(cur_cost+(cost//2),x,y))
                    else :
                        if dist[x][y] > cur_cost + cost :
                            dist[x][y] = cur_cost+cost
                            hq.heappush(pq,(cur_cost+cost,x,y))
        elif cur_a != a-1 and cur_b == b-1 : ## b만 도착한 경우
            ## a만 고려한다
            for x in path[cur_a] :
                if dist[x][cur_b] > cur_cost + path[cur_a][x] :
                    dist[x][cur_b] = cur_cost + path[cur_a][x]
                    hq.heappush(pq,(cur_cost+path[cur_a][x],x,cur_b))
        elif cur_a == a-1 and cur_b != b-1 : ## a만 도착한 경우
            ## b만 고려한다
            for x in path[cur_b] :
                if dist[cur_a][x] > cur_cost + path[cur_b][x] :
                    dist[cur_a][x] = cur_cost + path[cur_b][x]
                    hq.heappush(pq,(cur_cost+path[cur_b][x],cur_a,x))
        else : ## 둘 다 도착지에 도달한 경우
            continue

    answer = dist[a-1][b-1]

    return answer