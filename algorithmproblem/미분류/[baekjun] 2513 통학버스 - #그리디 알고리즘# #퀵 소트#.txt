주택난을 해결하기 위해서 직선 도로 하나를 따라 여러 아파트 단지들을 지었다. 또, 이 아파트 단지 주민을 위해 도로 위 한 지점에 학교 하나를 신설하였다. 아파트 단지들이 서로 멀리 떨어져 있기 때문에 반드시 통학버스를 이용해서만 다닐 수 있고, 통학버스는 한 대이다.

각각의 아파트 단지와 학교의 위치는 도로 위의 좌표로 주어지며, 또 각 아파트 단지마다 여기에 사는 학생들의 수도 주어진다. 통학버스는 아침에 학교를 출발하여 각 아파트 단지에 있는 학생들을 태우고 학교로 다시 돌아온다. 이 통학버스는 정원을 초과하여 학생을 태울 수 없고, 모든 학생을 등교시킬 때까지 이 과정을 반복한다. 



위 규칙을 따라서 모든 학생들을 학교에 등교시키는 예를 보자. 아파트 단지 A, B, C가 각각 좌표 0, 2, 5에 있고 이 단지에 사는 학생은 각각 1, 2, 1명이라고 하자. 두 지점 간의 거리는 두 지점 좌표의 차이로 정의된다. 최대 4명이 탈 수 있는 통학버스가 좌표 4에 있는 학교에서 출발해서 모든 학생들을 등교시킬 때, 버스는 먼저 단지 B를 들러 2명을 태우고, 단지 A를 들러서 1명을 태우고 다시 학교로 돌아온다면 이동 거리는 2 + 2 + 4 = 8이다. 다시 학교에서 아파트 단지 C로 이동하여 1명을 태우고 돌아오면 이동 거리는 1 + 1 = 2가 되고, 총 이동거리는 8 + 2 = 10이 된다. 

학교의 위치, 각각의 아파트 단지의 위치와 학생 수, 통학버스의 정원이 주어졌을 때, 모든 학생을 등교시키는데 필요한 통학버스의 총 이동 거리의 최솟값을 계산하는 프로그램을 작성하시오. 
----------------------------------------------------------------------------------------------------------------
//My sol
#include <stdio.h>

int N, K, S;
int a[30000 + 10];	// 좌표
int b[30000 + 10];	// 인원
int index;
int sol;

void quick_sort(int *data, int s, int e)	// 배열 , 시작 인덱스, 마지막 인덱스
{
	int i, j, tmp, key;

	if (s >= e)	 return;

	key = s;	// pivot
	i = s + 1;
	j = e;

	while (i <= j)
	{
		while (data[i] <= data[key] && i <= e)	i++;	// 왼->오 (pivot값보다 큰 값 찾기)
		while (data[j] >= data[key] && j >= s + 1) j--;	// 오->왼 (pivot값보다 작은 값 찾기)

		if (i > j)	// 엇갈린 경우
		{
			tmp = data[j];
			data[j] = data[key];
			data[key] = tmp;	// pivot과 j(작은 값)의 위치를 바꿈, 이 지점을 기준으로 좌 우 연산

			tmp = b[j];
			b[j] = b[key];
			b[key] = tmp;	// b 배열도 똑같이 교환
		}
		else // 엇갈리지 않은 경우
		{
			tmp = data[i];
			data[i] = data[j];
			data[j] = tmp;

			tmp = b[i];
			b[i] = b[j];
			b[j] = tmp; // b 배열도 똑같이 교환
		}
	}

	quick_sort(a, s, j - 1);
	quick_sort(a, j + 1, e);
}

int main(void)
{
	int i, j, cnt;

	scanf("%d %d %d", &N, &K, &S); // 단지, 정원, 학교

	for (i = 0; i < N; i++)
	{
		scanf("%d %d", &a[i], &b[i]);	// 좌표, 인원
	}

	quick_sort(a, 0, N - 1);	// 오름차순 정렬 (좌표기준)

	for (i = 0; i < N; i++)
	{
		if (a[i] > S)	break;	// break되지 않으면 i값은 N이 됨
	}

	index = i;	// index부터 학교의 오른쪽

	for (i = 0; i < index; i++)	// 왼쪽 연산
	{
		cnt = 0;
		for (j = i; j < index; j++)
		{
			cnt += b[j];	// 인원 수 더하기
			if (cnt > K)
			{
				b[j] = cnt - K;	// cnt - (정원)
				break;
			}
		}
		sol += (S - a[i]) * 2;	// 버스에 인원을 채우고 이동
		i = j - 1;	// 다음 i값이 j가 되기위해서 j-1를 입력
	}

	for (i = N - 1; i >= index; i--)	// 오른쪽 연산
	{
		cnt = 0;
		for (j = i; j >= index; j--)
		{
			cnt += b[j];
			if (cnt > K)
			{
				b[j] = cnt - K;
				break;
			}
		}
		sol += (a[i] - S) * 2;	// 버스에 인원을 채우고 이동
		i = j + 1;	// 다음 i값이 j가 되기위해서 j+1를 입력
	}

	printf("%d", sol);

	return 0;
}