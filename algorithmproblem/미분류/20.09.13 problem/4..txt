from collections import deque

## 진행방향에 대해서 왼쪽
dr = [0,-1,0,1]
dc = [1,0,-1,0] ## 오른쪽,위쪽,왼쪽,아래쪽

## 현재 진행방향에 대해 왼쪽
left = {0:1,1:2,2:3,3:0} ## (오른쪽:위쪽),(위쪽:왼쪽),(왼쪽:아래쪽),(아래쪽:오른쪽)

def solution(maze):
    answer = 0
    ## maze의 둘레를 dummy로 채운다.
    for i in range (len(maze)) :
        maze[i] = [1] + maze[i] + [1]
    tmp = [1]*(len(maze)+2)
    maze = [tmp] + maze + [tmp]
    N = len(maze)


    ## 출발
    q = deque()
    ## 출발 지점은 두 경우 밖에 없다.
    if maze[1][2] != 1:
        q.append((1,1,0))
    else:
        q.append((1,1,3))  ## (r,c,dir)

    cnt = 0
    while q :
        ##print(q)
        r, c, cur_dir = q.popleft()
        if r == N - 2 and c == N - 2:  ## 도착
            return cnt
        ## 현재 위치 기준 왼쪽 검색
        if maze[r + dr[left[cur_dir]]][c + dc[left[cur_dir]]] != 1:  ## 왼쪽이 벽이 아닌 경우
            ## 방향을 돌린다
            while True:
                cur_dir = (cur_dir + 1) % 4
                nr, nc = r + dr[cur_dir], c + dc[cur_dir]
                if nr < 0 or nr >= N+2 or nc < 0 or nc >= N+2:  ## 범위를 벗어나는 경우 계속해서 방향회전
                    continue
                if maze[nr][nc] == 1:  ## 벽인 경우
                    continue
                break
        nr = r + dr[cur_dir]
        nc = c + dc[cur_dir]
        if maze[nr][nc] == 1 : ## 진행 방향으로 갔을 때 벽일 때
            ##print(nr,nc,cur_dir)
            while True: ## 회전
                cur_dir = (cur_dir + 3) % 4
                nr, nc = r + dr[cur_dir], c + dc[cur_dir]
                if nr < 0 or nr >= N+2 or nc < 0 or nc >= N+2:  ## 범위를 벗어나는 경우 계속해서 방향회전
                    continue
                if maze[nr][nc] == 1:  ## 벽인 경우
                    continue
                ##print(nr,nc,cur_dir)
                break
        q.append((nr, nc, cur_dir))
        cnt += 1


    return answer